# **Документация проекта: Студия Подкастов с ИИ**

## 1. Обзор проекта

**Студия Подкастов с ИИ** — это передовое веб-приложение, предназначенное для автоматического создания коротких, атмосферных аудио-подкастов и видеоматериалов на заданную пользователем тему. Приложение генерирует полный пакет материалов: от уникального, SEO-оптимизированного сценария и профессиональной озвучки несколькими голосами до набора визуальных материалов, включая фоновые изображения и обложки для YouTube.

**Основная цель** — предоставить авторам, маркетологам и энтузиастам мощный инструмент для быстрого создания качественного контента, минимизируя ручной труд и предоставляя гибкие инструменты для итеративного улучшения результата.

### Ключевые возможности:

*   **Продвинутый AI-Копирайтинг:**
    *   Генерация **3-5 кликабельных, SEO-оптимизированных вариантов заголовка**.
    *   Динамическое обновление всех обложек при выборе нового заголовка в студии.
    *   Полный пакет текстовых материалов: описание, теги, уникальные персонажи и полный сценарий.
*   **Глобальный охват:** Удобный, **поисковый выпадающий список с более чем 40 языками** для генерации всего контента (текст, аудио) для международной аудитории.
*   **Гибкий источник знаний:**
    *   **Google Search:** ИИ использует поиск Google для сбора актуальной информации, если база знаний пуста.
    *   **Интерактивная База знаний:** Пользователь может вставить собственный текст или итеративно пополнять базу, задавая уточняющие вопросы, на которые ИИ находит ответы через Google.
*   **Настраиваемый стиль и длительность:**
    *   **Творческая свобода:** Генерация художественного, мистического рассказа в стиле Кинга/Лавкрафта.
    *   **Документальная точность:** Создание строгого, информативного подкаста.
    *   **Регулируемая длительность:** Пользователь может задать желаемую общую длительность подкаста.
*   **Отказоустойчивость и Fallback-механизмы:**
    *   **Текст:** При сбое основной модели (`gemini-2.5-pro`) система автоматически переключается на `gemini-2.5-flash` для всех текстовых генераций.
    *   **Изображения:** При исчерпании квот `Imagen`, система автоматически переключается на **Stable Diffusion XL** через OpenRouter.
    *   **Дизайн обложек:** При сбое AI-дизайнера используются три предопределенных резервных стиля.
*   **Интерактивная студия и гранулярный контроль:**
    *   Конвейерная генерация глав с возможностью **паузы и возобновления**.
    *   **Гранулярная регенерация:** Возможность пересоздать **отдельную главу** или **каждое отдельное изображение**.
    *   **Панель "Инструменты":** Обновление только текста, генерация нового набора изображений или полная переозвучка всех глав без изменения сценария.
*   **AI-дизайнер и редактор обложек:**
    *   ИИ анализирует тему и создает **3 уникальные дизайн-концепции** (шрифты, цвета).
    *   Встроенный **редактор обложек** для тонкой настройки текста, его положения, цвета и теней.
*   **Управление и тестирование:**
    *   **История проектов:** Сохранение и загрузка предыдущих проектов из `localStorage`.
    *   **Мульти-сервисное управление API-ключами:** Удобное модальное окно для ввода ключей Google Gemini и OpenRouter.
    *   **Панель тестирования AI-дизайнера** для быстрой визуальной проверки концепций.

## 2. Используемые технологии

*   **Фронтенд:**
    *   **React 19:** Современная библиотека для создания пользовательских интерфейсов.
    *   **TypeScript:** Строгая типизация для повышения надежности и масштабируемости кода.
    *   **Tailwind CSS:** Утилитарный CSS-фреймворк для быстрой и адаптивной верстки.
*   **Искусственный интеллект:**
    *   **Google Gemini API:**
        *   **`gemini-2.5-pro`:** Для сложных задач — генерации концепции, сценариев, AI-дизайна и работы с `googleSearch` tool.
        *   **`gemini-2.5-flash`:** Резервная модель для генерации текста.
        *   **`imagen-4.0-generate-001`:** Основная модель для генерации изображений.
        *   **`gemini-2.5-flash-preview-tts`:** Модель для синтеза речи (Text-to-Speech).
    *   **OpenRouter API:**
        *   **`stabilityai/sdxl`:** Запасная модель для генерации изображений.
*   **Браузерные API:**
    *   **Web Audio API:** Для обработки и сборки аудиофайлов в формате WAV.
    *   **Canvas API:** Для клиентской генерации и редактирования обложек.
    *   **LocalStorage API:** Для сохранения истории проектов и API-ключей.

## 3. Углубленный план рефакторинга

Компонент `App.tsx` значительно вырос и содержит в себе логику управления состоянием, отрисовку всех экранов и обработку пользовательских действий. Это затрудняет его поддержку и дальнейшее развитие. План направлен на его декомпозицию и улучшение архитектуры.

### Фаза 1: Извлечение логики и управление состоянием

**Цель:** Отделить логику управления состоянием и взаимодействия с API от UI-компонентов.

1.  **Создать кастомный хук `usePodcast.ts`:**
    *   **Ответственность:** Инкапсулировать всю бизнес-логику.
    *   **Состояние:** Будет управлять `podcast`, `isLoading`, `loadingStep`, `error`, `logs`.
    *   **Методы:** Будет предоставлять функции, такие как `startNewProject`, `generateSingleChapter`, `regenerateText`, `regenerateImage`, `selectTitle`, `updateThumbnail`, `combineAndDownload` и т.д. Вся работа с `ttsService` и `imageService` будет происходить здесь.

2.  **Создать кастомный хук `useHistory.ts`:**
    *   **Ответственность:** Управление историей проектов.
    *   **Состояние:** `history`.
    *   **Методы:** `loadHistory`, `updateHistory`, `clearHistory`. Будет инкапсулировать всю логику работы с `localStorage`.

3.  **Создать `PodcastProvider.tsx` с использованием React Context:**
    *   **Ответственность:** Предоставить состояние и методы из хука `usePodcast` всем дочерним компонентам.
    *   **Реализация:** Внутри `PodcastProvider` будет вызван хук `usePodcast`, а его возвращаемые значения (`podcast`, `isLoading`, `startNewProject` и т.д.) будут переданы через `Context.Provider`. Это устранит необходимость в `prop drilling`.

### Фаза 2: Декомпозиция UI на компоненты

**Цель:** Разбить монолитный `App.tsx` на логические, переиспользуемые компоненты.

1.  **Обновить `App.tsx`:**
    *   **Ответственность:** Станет корневым компонентом. Будет содержать `PodcastProvider`, `ApiKeyModal`, `LogPanel` и основную логику для переключения между главным экраном и студией.

2.  **Создать `NewProjectView.tsx`:**
    *   **Ответственность:** Отображение интерфейса, когда нет активного проекта.
    *   **Содержимое:** Будет включать в себя `ProjectSetupForm.tsx` и `HistoryPanel.tsx`.

3.  **Создать `StudioView.tsx`:**
    *   **Ответственность:** Основной "рабочий стол" для активного проекта. Будет получать все данные из `PodcastContext`.
    *   **Содержимое:** Будет состоять из более мелких, специализированных компонентов.

### Детальная структура компонентов `StudioView`:

```
StudioView.tsx
├── StudioHeader.tsx         # Заголовок и описание проекта.
├── TitleSelector.tsx        # Радио-кнопки для выбора заголовка.
├── CharactersPanel.tsx      # Отображение сгенерированных персонажей.
├── ChaptersList.tsx         # Список глав с их статусами, аудио-плеерами и кнопками регенерации.
│   └── ChapterItem.tsx      # Отдельный компонент для одной главы.
├── StudioToolbar.tsx        # Панель инструментов (обновить текст, новые изображения, переозвучить).
├── VisualsPanel.tsx         # Секция с обложками и изображениями.
│   ├── ThumbnailsGrid.tsx   # Сетка с вариантами обложек и кнопками "Редактировать".
│   └── ImagesGrid.tsx       # Сетка со сгенерированными изображениями и кнопками регенерации/скачивания.
├── TextAssetsPanel.tsx      # Секция с текстовыми материалами для копирования.
│   └── CopyableField.tsx    # Переиспользуемый компонент поля с кнопкой "Копировать".
└── StudioFooter.tsx         # Кнопки "Собрать и скачать" и "Начать новый проект".
```

### Результат рефакторинга:

*   **`App.tsx`** станет легким и будет отвечать только за высокоуровневую компоновку.
*   **Бизнес-логика** будет инкапсулирована в хуке `usePodcast`, что упростит ее тестирование и модификацию.
*   **UI-компоненты** будут маленькими, сфокусированными и получать данные через `Context`, что улучшит читаемость и переиспользуемость.
*   **Поток данных** станет однонаправленным и предсказуемым (`Context` -> `Component` -> `usePodcast` methods).

## 4. План развития (Roadmap)

Этот раздел описывает запланированные улучшения.

*   **Этап 1: Улучшение контроля и форматов**
    *   [ ] **Выбор компонентов для генерации:** Дать пользователю возможность выбирать, какие части проекта генерировать (например, только текст или только изображения).
    *   [ ] **Генерация субтитров (SRT):** Создание полноценного `.srt` файла с таймкодами.
    *   [ ] **Выбор формата сохранения:** Добавить опцию сохранения аудио в формате MP3.

*   **Этап 2: Расширенная кастомизация**
    *   [ ] **Пользовательские системные промпты:** Возможность для продвинутых пользователей изменять базовые инструкции для ИИ, чтобы адаптировать его под стиль своего канала.

*   **Этап 3: Переход к видео и звуку**
    *   [ ] **Создание видео-слайдшоу:** Автоматическая сборка видео из сгенерированных изображений с наложением аудиодорожки и настраиваемым интервалом смены кадров.
    *   [ ] **Автоматический подбор SFX:** Поиск и интеграция звуковых эффектов на основе ремарок в сценарии.
    *   [ ] **Подбор фоновой музыки:** Поиск и добавление фоновой музыки, соответствующей атмосфере подкаста.

*   **Этап 4: Новые форматы и автоматизация**
    *   [ ] **Генерация Reels/Shorts:** Отдельный рабочий процесс для создания коротких вертикальных видео.
    *   [ ] **Интеграция с Google Drive:** Автоматическая выгрузка всех материалов проекта (аудио, видео, текст, изображения) в папку на Google Drive пользователя.

## 5. Установка и запуск

Приложение является полностью клиентским и не требует серверной части.

1.  **API-ключи:** Для работы приложения необходимы API-ключи.
    *   **Google Gemini:** Может быть установлен в переменной окружения `process.env.API_KEY` или введен пользователем в настройках.
    *   **OpenRouter:** (Опционально, для фолбэка изображений) Вводится пользователем в настройках.
2.  **Запуск:** Просто откройте файл `index.html` в современном веб-браузере. Все зависимости (React, @google/genai) подгружаются через CDN, указанный в `importmap`.
